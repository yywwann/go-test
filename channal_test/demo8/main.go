package main

import (
	"fmt"
	"math/rand"
	"time"
)

func source(c chan<- int32) {
	ra, rb := rand.Int31(), rand.Intn(3)+1
	// 睡眠1秒/2秒/3秒
	time.Sleep(time.Duration(rb) * time.Second)
	c <- ra
}

// main
// 采用最快回应
// 本用例可以看作是上例中只使用一个通道变种的增强。
//
// 有时候，一份数据可能同时从多个数据源获取。
// 这些数据源将返回相同的数据。
// 因为各种因素，这些数据源的回应速度参差不一，甚至某个特定数据源的多次回应速度之间也可能相差很大。
// 同时从多个数据源获取一份相同的数据可以有效保障低延迟。我们只需采用最快的回应并舍弃其它较慢回应。
//
// 注意：如果有N个数据源，为了防止被舍弃的回应对应的协程永久阻塞，则传输数据用的通道必须为一个容量至少为N-1的缓冲通道。
func main() {
	rand.Seed(time.Now().UnixNano())

	startTime := time.Now()
	c := make(chan int32, 5) // 必须用一个缓冲通道
	for i := 0; i < cap(c); i++ {
		go source(c)
	}
	rnd := <-c // 只有第一个回应被使用了
	fmt.Println(time.Since(startTime))
	fmt.Println(rnd)
}

// 更多“请求/回应”用例变种
//做为函数参数和返回结果使用的通道可以是缓冲的，从而使得请求协程不需阻塞到它所发送的数据被接收为止。
//
//有时，一个请求可能并不保证返回一份有效的数据。对于这种情形，我们可以使用一个形如
//struct{
//	v T;
//	err error
//}
//的结构体类型或者一个空接口类型做为通道的元素类型以用来区分回应的值是否有效。
//
//有时，一个请求可能需要比预期更长的用时才能回应，甚至永远都得不到回应。 我们可以使用本文后面将要介绍的超时机制来应对这样的情况。
//
//有时，回应方可能会不断地返回一系列值，这也同时属于后面将要介绍的数据流的一个用例。
